<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
/*Promise - object that is used to determine failure or completion of async function
  States of promise -
    => pending- neither resolved or rejected  
    => fullfilled- resolved 
    => rejected- rejected
  Chainers,
    => .then()     normal chaining when the promise is resolved
    => .catch()    catches the rejection error    
    => .finally()  executes at the end even after catch block
  Promise have greater priority in event loops than the web apis and the setTimeout/setInterval functions.
*/


function myDisplay(some) {
    document.getElementById("demo").innerHTML = some;
  }
  
  let myPromise = new Promise(function(myResolve, myReject) {
    let x = 0;
  
    if (x == 0) {
      myResolve("OK");
    } else {
      myReject("Error");
    }
  });
  
  myPromise.then(
    function(value) {myDisplay(value);},
    function(error) {myDisplay(error);}
  );


/* Example with then,catch and await */
const playtime_request = (time) => {
    return new Promise((resolve, reject) => {
      if(!time || typeof(time) !== "number" || time > 3600){
        return reject("Overtime")
      }
      else{
        return resolve("Allowed")
      }
    })
  }
  
  playtime_request(30000)
  .then((res) => console.log(res + "- Hurray!"))
  .catch((error) => console.log((error + "- Oh no!")))
  
  
  // g promise response stored in another variable
  const func = async () => {
    let response;
    await playtime_request(3000)
    .then((res) => {
      response = res
    })
    .catch((error) => {
      response = error
    })
    console.log(response)
  }
  func()


  </script>
</body>
</html>
  